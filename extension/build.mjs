/**
 * build.mjs - Extension build script
 * Generates redactor rules and prepares extension files
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);

const PATTERN_FILE = path.join(__dirname, 'src', 'patterns.json');
const GEN_DIR      = path.join(__dirname, 'src', 'gen');
const OUT_FILE     = path.join(GEN_DIR, 'redactorRules.js');
const DIST_DIR     = path.join(__dirname, 'dist');

// Read patterns and generate redactor rules
const { identifiers } = JSON.parse(fs.readFileSync(PATTERN_FILE, 'utf8'));

function mkReplacer(entry) {
  const safeID = (entry.id || entry.name || 'token')
    .toString().toUpperCase().replace(/\s+/g, '_');
  
  if (entry.jsReplacer) {
    return entry.jsReplacer.trim();
  }

  if (entry.mask !== undefined) {
    const mask = entry.mask;
    if (mask.includes('$')) {
      return `(m,...g)=>${JSON.stringify(mask)}
        .replace('$&',m)
        .replace(/\\$(\\d)/g,(_,i)=>g[i-1]||'')`;
    }
    return `() => ${JSON.stringify(mask)}`;
  }

  return `() => "<${safeID}>-"`;
}

const ruleLines = identifiers.map((p) => {
  const flags = p.flags || 'g';
  const id = p.id || (p.name ?? '').toLowerCase().replace(/\s+/g, '_');
  return `  {
    id: "${id}",
    pattern: new RegExp(${JSON.stringify(p.pattern)}, "${flags}"),
    replacer: ${mkReplacer(p)}
  }`;
}).join(',\n');

const out = `// AUTO-GENERATED by build.mjs â€“ DO NOT EDIT
export const rules = [
${ruleLines}
];
`;

fs.mkdirSync(GEN_DIR, { recursive: true });
fs.writeFileSync(OUT_FILE, out, 'utf8');
console.log('[Extension Build] Generated redactorRules.js');

// Clean and create dist directory
if (fs.existsSync(DIST_DIR)) {
  fs.rmSync(DIST_DIR, { recursive: true, force: true });
}
fs.mkdirSync(DIST_DIR, { recursive: true });

// Create subdirectories
const distDirs = [
  path.join(DIST_DIR, 'icons'),
  path.join(DIST_DIR, 'popup'),
  path.join(DIST_DIR, 'src')
];

distDirs.forEach(dir => {
  fs.mkdirSync(dir, { recursive: true });
});

// Copy manifest.json
fs.copyFileSync(
  path.join(__dirname, 'manifest.json'),
  path.join(DIST_DIR, 'manifest.json')
);

// Copy icons
const iconsSource = path.join(__dirname, 'icons');
if (fs.existsSync(iconsSource)) {
  const iconFiles = fs.readdirSync(iconsSource);
  iconFiles.forEach(file => {
    fs.copyFileSync(
      path.join(iconsSource, file),
      path.join(DIST_DIR, 'icons', file)
    );
  });
  console.log('[Extension Build] Copied', iconFiles.length, 'icon files');
}

// Copy popup files
const popupSource = path.join(__dirname, 'popup');
if (fs.existsSync(popupSource)) {
  const popupFiles = fs.readdirSync(popupSource);
  popupFiles.forEach(file => {
    fs.copyFileSync(
      path.join(popupSource, file),
      path.join(DIST_DIR, 'popup', file)
    );
  });
  console.log('[Extension Build] Copied', popupFiles.length, 'popup files');
}

// Copy web accessible resources
const srcFiles = [
  'detectorWorker.js',
  'patterns.json'
];

srcFiles.forEach(file => {
  const srcPath = path.join(__dirname, 'src', file);
  const destPath = path.join(DIST_DIR, 'src', file);
  if (fs.existsSync(srcPath)) {
    fs.copyFileSync(srcPath, destPath);
    console.log(`[Extension Build] Copied ${file}`);
  }
});

console.log('[Extension Build] Build preparation complete!');